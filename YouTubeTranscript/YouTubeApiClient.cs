using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Linq;

class YouTubeApiClient
{
    private readonly HttpClient _httpClient;
    private const string PlayerApiUrl = "https://www.youtube.com/youtubei/v1/player";
    private const string AndroidClientName = "ANDROID";
    private const string AndroidClientVersion = "19.09.37";

    public YouTubeApiClient()
    {
        _httpClient = new HttpClient();
        // Set user agent to impersonate Android client
        _httpClient.DefaultRequestHeaders.Add("User-Agent",
            "com.google.android.youtube/19.09.37 (Linux; U; Android 11) gzip");
        _httpClient.DefaultRequestHeaders.Add("Accept", "application/json");
        _httpClient.DefaultRequestHeaders.Add("Accept-Language", "en-US,en;q=0.9");
    }

    public static string ExtractVideoId(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            throw new ArgumentException("Input cannot be empty", nameof(input));
        }

        // Direct video ID (11 characters, alphanumeric and hyphens/underscores)
        if (Regex.IsMatch(input, @"^[a-zA-Z0-9_-]{11}$"))
        {
            return input;
        }

        // youtube.com/watch?v=VIDEO_ID
        var match = Regex.Match(input, @"(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})");
        if (match.Success)
        {
            return match.Groups[1].Value;
        }

        throw new ArgumentException("Invalid YouTube URL or video ID", nameof(input));
    }

    public async Task<VideoInfo> GetVideoInfoAsync(string videoId)
    {
        var playerResponse = await GetPlayerResponseAsync(videoId);

        if (!playerResponse.TryGetProperty("videoDetails", out var videoDetails))
        {
            throw new Exception($"Video not found: {videoId}");
        }

        var title = videoDetails.GetProperty("title")
            .GetString() ?? "Unknown";

        var description = videoDetails.TryGetProperty("shortDescription", out var descProp)
            ? descProp.GetString()
            : null;

        return new VideoInfo
        {
            Id = videoId,
            Title = title,
            Description = description
        };
    }

    public async Task<List<CaptionInfo>> ListCaptionsAsync(string videoId)
    {
        var playerResponse = await GetPlayerResponseAsync(videoId);
        var captions = new List<CaptionInfo>();

        // Check for captions in the player response
        if (playerResponse.TryGetProperty("captions", out var captionsProp))
        {
            if (captionsProp.TryGetProperty("playerCaptionsTracklistRenderer", out var playerCaptions))
            {
                if (playerCaptions.TryGetProperty("captionTracks", out var captionTracks))
                {
                    foreach (var track in captionTracks.EnumerateArray())
                    {
                        if (!track.TryGetProperty("baseUrl", out var baseUrlProp) ||
                            !track.TryGetProperty("languageCode", out var langProp))
                        {
                            continue;
                        }

                        var baseUrl = baseUrlProp.GetString();
                        var languageCode = langProp.GetString() ?? "unknown";

                        string name = languageCode;
                        if (track.TryGetProperty("name", out var nameProp))
                        {
                            if (nameProp.TryGetProperty("simpleText", out var simpleText))
                            {
                                name = simpleText.GetString() ?? languageCode;
                            }
                            else if (nameProp.ValueKind == JsonValueKind.String)
                            {
                                name = nameProp.GetString() ?? languageCode;
                            }
                        }

                        var isAutoGenerated = track.TryGetProperty("kind", out var kindProp)
                            && kindProp.GetString() == "asr";

                        if (!string.IsNullOrWhiteSpace(baseUrl))
                        {
                            captions.Add(new CaptionInfo
                            {
                                Id = baseUrl,
                                Language = languageCode,
                                Name = name,
                                BaseUrl = baseUrl,
                                IsAutoGenerated = isAutoGenerated
                            });
                        }
                    }
                }
            }
        }

        return captions;
    }

    public async Task<string> DownloadTranscriptAsync(string captionUrl)
    {
        if (string.IsNullOrWhiteSpace(captionUrl))
        {
            throw new ArgumentException("Caption URL cannot be empty", nameof(captionUrl));
        }

        // Ensure the URL has the fmt parameter to get XML format
        var url = captionUrl;
        if (!url.Contains("fmt="))
        {
            url += (url.Contains("?") ? "&" : "?") + "fmt=xml3";
        }

        var response = await _httpClient.GetStringAsync(url);
        return response;
    }

    public async Task<string> DownloadTranscriptAsTextAsync(string captionUrl)
    {
        try
        {
            var transcriptXml = await DownloadTranscriptAsync(captionUrl);

            // Debug: Log first 200 chars of response
            if (transcriptXml.Length > 0)
            {
                var preview = transcriptXml.Length > 200 ? transcriptXml.Substring(0, 200) : transcriptXml;
                Console.WriteLine($"Transcript preview (first 200 chars): {preview}");
            }

            return ExtractTextFromTranscript(transcriptXml);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error downloading transcript: {ex.Message}");
            throw;
        }
    }

    private async Task<JsonElement> GetPlayerResponseAsync(string videoId)
    {
        // Create request payload that mimics Android client
        var requestPayload = new
        {
            context = new
            {
                client = new
                {
                    clientName = AndroidClientName,
                    clientVersion = AndroidClientVersion,
                    androidSdkVersion = 30,
                    userAgent = "com.google.android.youtube/19.09.37 (Linux; U; Android 11) gzip",
                    hl = "en",
                    gl = "US",
                    utcOffsetMinutes = 0
                }
            },
            videoId = videoId
        };

        var jsonPayload = JsonSerializer.Serialize(requestPayload);
        var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

        var response = await _httpClient.PostAsync(PlayerApiUrl, content);
        response.EnsureSuccessStatusCode();

        var responseJson = await response.Content.ReadAsStringAsync();

        if (string.IsNullOrWhiteSpace(responseJson))
        {
            throw new Exception("Empty response from YouTube player API");
        }

        var doc = JsonDocument.Parse(responseJson);

        return doc.RootElement;
    }

    private string ExtractTextFromTranscript(string transcriptXml)
    {
        if (string.IsNullOrWhiteSpace(transcriptXml))
        {
            return string.Empty;
        }

        // Debug: Check first 500 chars to see what format we're dealing with
        var preview = transcriptXml.Length > 500 ? transcriptXml.Substring(0, 500) : transcriptXml;
        if (preview.Contains("<transcript>") || preview.Contains("<text"))
        {
            // This looks like XML format
        }
        else
        {
            // Might be JSON or another format - try fallback first
            return ExtractTextFallback(transcriptXml);
        }

        try
        {
            var doc = XDocument.Parse(transcriptXml);
            var textElements = new List<string>();

            // YouTube transcript XML typically has <text> elements with start, dur, and text content
            // Format: <text start="0" dur="5.5">Hello world</text>
            var textNodes = doc.Descendants("text");

            foreach (var textNode in textNodes)
            {
                // Get text content directly from the element
                var text = textNode.Value;

                // If Value is empty, the text might be in a child node or CDATA
                if (string.IsNullOrWhiteSpace(text))
                {
                    // Try to get text from all text nodes
                    var textNodes2 = textNode.DescendantNodes().OfType<XText>();
                    text = string.Join(" ", textNodes2.Select(t => t.Value));
                }

                // If still empty, try getting inner XML and stripping tags
                if (string.IsNullOrWhiteSpace(text))
                {
                    var innerXml = textNode.ToString();
                    // Extract content between > and <
                    var match = Regex.Match(innerXml, @">([^<]+)<");
                    if (match.Success)
                    {
                        text = match.Groups[1].Value;
                    }
                }

                if (!string.IsNullOrWhiteSpace(text))
                {
                    // Decode HTML entities
                    text = System.Net.WebUtility.HtmlDecode(text);
                    // Remove any remaining XML tags
                    text = Regex.Replace(text, @"<[^>]+>", "");
                    text = text.Trim();

                    if (!string.IsNullOrWhiteSpace(text))
                    {
                        textElements.Add(text);
                    }
                }
            }

            // If no text found with standard parsing, try fallback
            if (textElements.Count == 0)
            {
                return ExtractTextFallback(transcriptXml);
            }

            return string.Join("\n", textElements);
        }
        catch (Exception ex)
        {
            // If XML parsing fails, try to extract text using regex as fallback
            Console.WriteLine($"XML parsing error: {ex.Message}");
            return ExtractTextFallback(transcriptXml);
        }
    }

    private string ExtractTextFallback(string content)
    {
        var textLines = new List<string>();

        // Try multiple patterns to extract text
        // Pattern 1: <text>content</text>
        var matches = Regex.Matches(content, @"<text[^>]*>(.*?)</text>", RegexOptions.Singleline | RegexOptions.IgnoreCase);

        if (matches.Count == 0)
        {
            // Pattern 2: <text start="..." dur="...">content</text>
            matches = Regex.Matches(content, @"<text[^>]*>([^<]+)</text>", RegexOptions.Singleline | RegexOptions.IgnoreCase);
        }

        if (matches.Count == 0)
        {
            // Pattern 3: Look for any text between tags
            matches = Regex.Matches(content, @">([^<]+)<", RegexOptions.Singleline | RegexOptions.IgnoreCase);
        }

        foreach (Match match in matches)
        {
            if (match.Groups.Count > 1)
            {
                var text = match.Groups[1].Value;
                text = System.Net.WebUtility.HtmlDecode(text);
                text = Regex.Replace(text, @"<[^>]+>", ""); // Remove any nested tags
                text = text.Trim();

                // Skip if it looks like a timestamp or attribute value
                if (!string.IsNullOrWhiteSpace(text) &&
                    !Regex.IsMatch(text, @"^\d+\.?\d*$") && // Not just numbers
                    !text.StartsWith("start=") &&
                    !text.StartsWith("dur="))
                {
                    textLines.Add(text);
                }
            }
        }

        return string.Join("\n", textLines);
    }
}

class VideoInfo
{
    public string Id { get; set; } = string.Empty;
    public string Title { get; set; } = string.Empty;
    public string? Description { get; set; }
}

class CaptionInfo
{
    public string Id { get; set; } = string.Empty;
    public string Language { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string BaseUrl { get; set; } = string.Empty;
    public bool IsAutoGenerated { get; set; }
}
